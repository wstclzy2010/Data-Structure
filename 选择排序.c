#include <stdio.h>
#include <stdbool.h>

/*
    简单选择排序和堆排序都是基于“选择排序”的原理，每次在未排序序列中“选择”出一个最小或者最大的元素放到最前面或后面。
        发现所有
    1.简单选择排序是选择一个最小的元素，与最前面的未排序元素交换，有序子序列+1，未排序序列-1，一定需要排序n-1趟。
        简单选择排序的趟数永远是n-1,元素间的比较次数永远是n(n-1)/2,时间永远是O(n^2)，这三者与序列初始状态无关
    2.堆属于完全二叉树，每个子树的根结点<=左右孩子结点——小根堆；每个子树的根结点>=左右孩子结点——大根堆
    3.堆排序利用大根堆数组第一个元素为关键字最大的特性，选择最大的元素与最后面的未排序元素交换，最后形成递增序列；
        如果是使用小根堆，则每次将最小的元素与最后面的未排序元素交换，最后形成递减序列。
        堆排序和快速排序一样时间复杂度都是O(nlog2(n))，但堆排序时间复杂度永远是这个
            两个都是不稳定的，同性能只有归并排序是稳定的。
    4.堆是完全二叉树按照层次遍历顺序存储到一维数组当中的，所以堆排序利用了顺序存储的随机访问的特性，
        当采用链式存储会增加时间复杂度
*/

//交换两个数组元素
void swap(int *a, int *b)
{
    int tmp = *a; //不能交换数组的地址，因为静态数组的地址不能改变
    *a = *b;
    *b = tmp;
}

//简单选择排序，时间复杂度永远是O(n^2)，空间复杂度O(1)，不稳定。
void selectSort(int A[], int n)
{
    for (int i = 0; i < n - 1; i++) //因为经过n-1趟选择后，待排元素只剩下一个，最后一个元素肯定是最大元素
    {                               //没必要多进行一趟排序
        int min = i;                //把A[i]当成是最小元素
        for (int j = i + 1; j < n; j++)//在A[i+1]~A[n-1]中选择(比较)出最小元素
            if (A[j] < A[min])
                min = j;            //筛选出最小的
        if (min != i)               //A[i]并非最小
            swap(A + min, A + i);   //交换A[i]和A[min]，即每次将一个最小元素加入到前面有序序列的最后面
    }
}
////////////////////////////////////////////////////////////////
//调整为大根堆，检查所有非终端结点，让其符合大根堆要求。即小的元素不断下坠，堆顶为关键字最大的节点
void adjustMaxHeap(int A[], int root, int len)
{
    A[0] = A[root];                          //暂存子树的根结点，防止被覆盖
    for (int i = 2 * root; i <= len; i *= 2) //2i为当前结点的左孩子；i=i*2，即以左孩子为根的左孩子
    {                                        //结点编号最大只能是数组长度
        if (i < len && A[i] < A[i + 1])      //i小于len才有右孩子
            i++;
        if (A[0] > A[i]) //已经满足根值大于等于左右孩子(大根堆要求)，退出循环
            break;
        else                //该else分支实现小元素下坠
        {
            A[root] = A[i]; //根值小于孩子值，让值更大的孩子替换根结点(大元素上升)
            root = i;       //让孩子作为根结点，继续从它的孩子中筛选
        }                   //root所指的位置实际就是正在筛选的有可能插入待调整元素的位置
    }
    A[root] = A[0];         //将A[0]这个被筛选的元素放入root这个最终位置上(小元素下坠完成)
}
//建立大根堆
void buildMaxHeap(int A[], int len)
{           /*从编号最大的分支结点(非叶结点)开始,调整所有的分支结点，让其符合大根堆的要求(即一维数组从n/2往前)*/
    for (int branchNode = len / 2; i > 0; i--) //A[0]空出来，不存放元素；非终端结点编号i<=n/2(向下取整)
        adjustMaxHeap(A, branchNode, len);
}
//堆排序(大根堆)，时间复杂度O(nlog2(n))，空间复杂度O(1)，不稳定。
void heapSort(int A[], int len)
{
    buildMaxHeap(A, len);          //建好大根堆后，数组的第一个元素A[1](堆顶元素)存放的是值最大的元素
    for (int i = len; i > 1; i--)  //从后往前，把最大值放到后面，每次未排序序列元素减一，有序元素加一
    {
        swap(A + i, A + 1);        //把当前未排序序列的最大元素放到尾部
        adjustMaxHeap(A, 1, i - 1);//由于A[1]已经不是最大元素，A[i]已经有序
    }                              //，需要从A[1]到A[i-1]重新调整以符合大根堆要求
}

/*
    堆的插入：
        在堆底(即一维数组最后一个元素的后面)插入元素，让其与父节点比较，使得小元素不断上升(小根堆)，直到无法上升
                                                                 大元素不断上升(大根堆)，直到无法上升
            一次上升只比较 一 次关键字
    堆的删除：
        用堆底元素代替被删除的元素的位置，在该位置重新调整堆，让其不断下坠(小根堆)/不断上升(大根堆)，直到无法XX
            一次下坠如果有两个孩子则需要对比 两次 关键字
*/




int main(int argc, char const *argv[])
{
    /* code */
    return 0;
}
